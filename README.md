# loadgenerator
载荷发生器
术语解释：
QPS（Query Per Second，每秒查询量）
TPS（Transactions Per Second，每秒事务处理量）
QPS、TPS均为1s内可以正常请求响应的数量的平均值，其差别：QPS是针对服务器上数据读取的操作，TPS针对的是服务器上数据写入和修改的操作。

LPS（Loads Per Second，每秒载荷量）
LPS为软件使用者为获得数据向软件请求的数据以获得响应，其每秒发送请求的数量称之为：每秒载荷量。

载荷发生器的基本结构：
一、参数：
载荷发生器根据以下参数自行计算出载荷发生以及发送的频率，并计算好并发量。
1、每秒载荷量（lps）：软件使用者每秒发送请求的数量。
说明：可通过该参数控制载荷发生器向软件发送请求的频率，控制软件在一段时间之内的负载情况。

2、负载持续时间（durationNS）：持续发送载荷的时间。
说明：可通过设定此时间分析出此时间段内软件性能的具体情况，同时也有机会使用一些方法获得软件对系统资源的使用情况，并以此推断出软件对各种系统资源的依赖情况，以及他们去软件想能之间的关系，有助于查找软件内部的设计缺陷。

3、处理超时时间（timeoutNS）：从软件发出请求到接收响应的最大耗时。
说明：评判软件正确性的重要标准，超过此最大耗时就认为是不可接受的，当此处理被认为无效处理，需要进行相关的优化处理。

二、控制：
4、载荷并发量（concurrency）：处理超时时间/每秒载荷量≈荷载并发量。
说明：使用此字段知道实际载荷发送操作

5、票池(tickets)：以一个缓冲通道作为载体，票池中票的数量为（4、载荷并发量）。
说明：通过票池限定goroutine的数量，以防止goroutine过多导致的程序性能下降或过少使并发量不够，导致系统资源利用不充分。
票池的结构包括：
1、票的总数（total uint32）：初始化为：载荷并发量，对应载荷结构中的字段 concurrency（并发量），在Total方法被调用后会及时返回新的票总数
2、票的容器（ticketCh chan struct{}）：在Remainder方法调用后会及时返回剩余票的总数
3、是否被激活（Active bool）：票池正确初始化返回true
票池的接口方法：
1、获得一张票（Take）-1操作
2、归还一张票（Return）+1操作
3、票池是否被激活（Active 返回bool）
4、票的总数 （Total 返回uint32）
5、剩余票数 （Remainder 返回 uint32）
票池可以看成事一个多值信号量，多值信号量的值代表了可用资源的数量，在获得或归还资源时会及时减少或增加该信号量的值，以便其他使用方及时了解资源的使用情况，在该值被减至0时所有使用该值的程序都会被阻塞，直至该值重新增至一个正整数，这些程序才会被唤醒。接口的实现方法 Take和Return对应相关的-1或+1操作。



6、取消函数（cancelFunc）：使用context.CancelFunc,可用于手动通知停止
   上下文（ctx）  ：使用context.Context,上下文
说明：载荷发生器的停止：使用标准库的context包中的Context接口类型和函数标记载荷发生器的停止

三：状态：
7、载荷发生器状态（status）：用于标记发生器的状态，该标记必须短小，可以使用并发安全的方式操作且不包含负数，因此选用uint32作为状态类型。
说明：为发生器状态声明5种常量便于赋值，1、初始状态 2、正在启动 3、已启动 4、正在停止 5、已停止

四、扩展和定制：
8、扩展接口（组件功能）（caller）：用于根据具体需求对载荷发生器进行适当的扩展和定制。
说明：为保证核心功能的稳定以及提供较高的可扩展，该接口功能与以上核心功能区分开，核心功能：用于提供控制和协调载荷的生成、发送、响应的接收和验证；扩展功能（组件功能）：与调用被测软件的API功能应该作为组建功能，这涉及请求的发送操作、响应的接受操作、请求的生成操作、响应的检查操作。

五、结果：
9、输出的结果（resultCh）：使用通道类型的结果列表。
说明：该字段需要并发的输出结果，所以必须为并发安全类型。针对每个载荷（也称请求必须包含三个参数），也就是按照响应的到达顺序排列的一个结果列表：
1、载荷和响应的内容
2、响应的状态
3、请求处理耗时


以上字段结构说明：
1-3：载荷重要参数
4-6：控制作用的字段
7：标记发生器状态
8：用于扩展和定制
9：输出的结果列表

代码示例地址：

初始化：
创建和初始化复杂的结构体通常使用“New”作为函数名称的前缀。

一、创建载荷发生器 func NewGenerator(pset ParamSet) (lib.Generator, error) {}：
参数：该函数具有五个参数（内置到ParamSet结构类型中），与发生器基本结构的字段对应：
1、扩展函数（组件功能）（caller）
2、处理超时时间（timeoutNS）
3、每秒载荷量（lps）
4、负载持续时间（durationNS）
5、返回结果（resultCh）
6、状态（status）：该参数为声明的常量:1、初始状态
返回：
1、接口（载荷发生器）该接口内暴露四个方法1、启动载荷发生器 2、停止载荷发生器 3、获取状态 4、获取调用计数（每次启动重置该计数）
2、error
说明：为避免代码耦合导致程序扩展产生的散弹式修改，该函数遵循面向接口编程原则以及开闭原则对修改关闭对扩展开放以实现热插拔的效果。
函数实现：
1、检查传入参数是否合法 
2、给基本字段进行赋值
3、调用基本字段的（二、初始化方法）
4、返回赋值结果和error

二、初始化方法 func (gen *myGenerator) init() error{}：
函数实现：
1、通过每秒载荷量和处理超时时间获得平均并发量，该值赋值给基本结构字段（并发量：concurrency）
   并发量≈载荷的响应超时时间/载荷发送间隔时间
   concurrency=timeoutNS/(1e9/lps)+1
说明：
1）、timeoutNS表示单个载荷响应超时的时间，操作一个载荷的时间超过该时间，则会被判定为违背成功响应；如操作一个载荷未超过该时间，接受该载荷相应的操作不会强制结束；
2）、（1e9/lps）:表示将载荷发送间隔时间换算为ns；
3）、+1操作表示在某个时间周期之初，想被测软件发送的那个载荷

2、将并发量（某段时间内的并发量的最大值）赋值给票池初始化函数（func NewGoticket(total uint32)(GoTickets,error){}） 并返回票池内容 票总数total、票容器（票的剩余数量）ticketCh、是否激活active

启动和停止：
载荷发生器的启动和停止，包含以下过程：
1、调用Start可以启动载荷发生器
2、按照指定参数向被测软件发送一定量的载荷
3、指定负责持续时间之后，载荷会自动停止在和发送操作；
从启动到停止这一过程种，被测软件对各载荷的响应、在和发送操作的最终结果收集起来，并发送调用的结果通道；

一、启动准备：
1、检查载荷发生器是否为可启动状态，使用atomic相关函数设置为启动状态
2、使用durationNS初始化上下文和取消函数、初始化调用参数、设置发生器已启动状态
3、使用并发关键字调用匿名方法 生成并发送函数
说明：以上步骤完成，发生器进入（启动状态），载荷发生器才真正开始生成并发送载荷
二、控制流程
以下步骤包含了载荷发送操作和载荷响应接收操作的调用操作是异步执行的，以此实现载荷发生器的并发运行
1、接受节流阀作为参数，周期性的向被测软件发送载荷，周期的长短由节流阀控制
2、判断lps（每秒载荷量）若大于0表示节流阀有效并需要使用，通过接收context的上下文信号判断是否停止载荷发生器

三、异步的调用：
在控制流程的周期性循环中调用此方法，使控制流程和调用流程分离，实现在和发送操作的异步性和并发行。
  一个调用过程分为五个步骤：（1）生成载荷 （2）发送载荷并接收响应 （3）检查载荷响应 （4）生成调用结果 （5）发送调用结果
1、在生成载荷之前，需要对票池进行操作，在启用之前获得一张票，在匿名go函数结束时使用defer关键字归还一张票，若票池中无剩余票则会阻塞

2、生成载荷：使用调用方传入的调用器

3、发送载荷并接收响应：使用time包中的定时器（time.AfterFunc()）和timeoutNS设定超时时间，做到实时的超时判断，声明调用状态 callStatus；使用time.AfterFunc设定超时之后的处理

4、检查载荷响应：判断发送载荷的调用状态callStatus，如果未调用或调用中则刚改为调用完成

5、生成调用结果：首先检查载荷发生器状态，如果状态为已启动、通道已满则不能发送，所以需要select语句中添加default分支并记录为发送结果，确保不会发生阻塞

6、发送调用结果：生成的结果使用管道发送至resultCh

四、停止
1、检查载荷发生器状态
2、执行cancelFunc代表的方法发出停止“信号”
3、检查发生器停止状态的变更
4、变更完毕停止检查状态，停止完成


